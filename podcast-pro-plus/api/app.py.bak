from __future__ import annotations

import os
from pathlib import Path

log = logging.getLogger(__name__)

# Cloud Run-safe writable defaults under /tmp
FINAL_DIR = Path(os.getenv("FINAL_DIR", "/tmp/final_episodes"))
MEDIA_DIR = Path(os.getenv("MEDIA_DIR", "/tmp/media_uploads"))
FLUBBER_DIR = Path(os.getenv("FLUBBER_CONTEXTS_DIR", "/tmp/flubber_contexts"))

for d in (FINAL_DIR, MEDIA_DIR, FLUBBER_DIR):
    try:
        d.mkdir(parents=True, exist_ok=True)
    except Exception as e:
        log.warning("Could not create static dir %s: %s", d, e)


import api.db_listeners  # registers SQLAlchemy listeners
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles
from fastapi.responses import JSONResponse
from starlette.middleware.sessions import SessionMiddleware

from api.core.config import warn_if_secrets_missing
from api.core.database import engine
from api.core.logging import configure_logging, get_logger
from api.core.paths import FINAL_DIR, MEDIA_DIR, FLUBBER_CTX_DIR
from api.exceptions import install_exception_handlers
from api.limits import limiter, DISABLE as RL_DISABLED

# optional rate-limit middleware
try:
    from slowapi.middleware import SlowAPIMiddleware
    from slowapi.errors import RateLimitExceeded
except Exception:  # pragma: no cover
    SlowAPIMiddleware = None  # type: ignore
    RateLimitExceeded = None  # type: ignore

# split-out helpers
from api.startup_tasks import run_startup_tasks, _compute_pt_expiry
from api.routing import attach_routers

# --- logging ASAP ---
configure_logging()
log = get_logger("api.app")

# --- sentry (no-op in dev/test) ---
SENTRY_DSN = os.getenv("SENTRY_DSN")
ENV = os.getenv("APP_ENV") or os.getenv("ENV") or os.getenv("PYTHON_ENV") or "dev"
if SENTRY_DSN and ENV not in ("dev", "development", "test", "testing", "local"):
    try:
        import sentry_sdk
        from sentry_sdk.integrations.fastapi import FastApiIntegration
        from sentry_sdk.integrations.logging import LoggingIntegration

        sentry_sdk.init(
            dsn=SENTRY_DSN,
            integrations=[FastApiIntegration(), LoggingIntegration(level=None, event_level=None)],
            traces_sample_rate=float(os.getenv("SENTRY_TRACES_SAMPLE_RATE", "0.0")),
            profiles_sample_rate=float(os.getenv("SENTRY_PROFILES_SAMPLE_RATE", "0.0")),
            environment=ENV,
            send_default_pii=False,
        )
        log.info("[startup] Sentry initialized for env=%s", ENV)
    except Exception as se:
        log.warning("[startup] Sentry init failed: %s", se)
else:
    log.info("[startup] Sentry disabled (missing DSN or dev/test env)")

# --- early secrets sanity (warn outside prod; fail in prod) ---
try:
    warn_if_secrets_missing()
except Exception as e:
    if ENV.lower() in ("prod", "production"):
        log.error("Secrets validation failed: %s", e)
        raise
    else:
        log.warning("Secrets validation issues (non-prod): %s", e)

# --- build app ---
app = FastAPI(title="Podcast Pro Plus API")

# DB/tables and additive migrations, backfills, etc.
run_startup_tasks()

# Exceptions & base middlewares
app.add_middleware(SessionMiddleware,
    secret_key=(
        os.getenv("SESSION_SECRET")
        or os.getenv("SESSION_SECRET_KEY")
        or "dev-insecure-session-secret-change-me"
    ),
    session_cookie="ppp_session",
    max_age=60 * 60 * 24 * 14,
    same_site="lax",
    https_only=False,  # set True when behind HTTPS/proxy
)
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # tighten in prod if desired
    allow_methods=["*"],
    allow_headers=["*"],
    allow_credentials=True,
)

# Request ID / Security headers
from api.middleware.request_id import RequestIDMiddleware
from api.middleware.security_headers import SecurityHeadersMiddleware
app.add_middleware(RequestIDMiddleware)
app.add_middleware(SecurityHeadersMiddleware)

install_exception_handlers(app)

# Rate limiting (if enabled)
if not RL_DISABLED and getattr(limiter, "limit", None):
    app.state.limiter = limiter
    if SlowAPIMiddleware is not None:
        app.add_middleware(SlowAPIMiddleware)
    if RateLimitExceeded is not None:
        async def _rate_limit_handler(request, exc):  # type: ignore
            return JSONResponse(status_code=429, content={"detail": "Too many requests"}, headers={"Retry-After": "60"})
        app.add_exception_handler(RateLimitExceeded, _rate_limit_handler)  # type: ignore

# Ensure static dirs exist (Cloud Runâ€™s FS is ephemeral)
for _d in (FINAL_DIR, MEDIA_DIR, FLUBBER_CTX_DIR):
    try:
        Path(_d).mkdir(parents=True, exist_ok=True)
    except Exception as e:
        log.warning("Could not create static dir %s: %s", _d, e)

# Static mounts
app.mount("/static/final", StaticFiles(directory=str(FINAL_DIR), check_dir=False), name="final")
app.mount("/static/media", StaticFiles(directory=str(MEDIA_DIR), check_dir=False), name="media")
app.mount("/static/flubber", StaticFiles(directory=str(FLUBBER_CTX_DIR)), name="flubber")

# Routers
attach_routers(app)

# Root & health
@app.get("/")
def root():
    return {"ok": True}

@app.get("/api/health")
def api_health_alias():
    return {"status": "ok"}

@app.get("/healthz")
def healthz():
    # liveness: no DB
    return {"ok": True}

@app.get("/readyz")
def readyz():
    # readiness: light DB check
    try:
        with engine.connect() as conn:
            conn.exec_driver_sql("SELECT 1")
        return {"ok": True}
    except Exception as e:
        return JSONResponse(status_code=500, content={"ok": False, "error": str(e)})

# Re-export so legacy imports of api.main:_compute_pt_expiry (via api.app) still work
__all__ = ["app", "_compute_pt_expiry"]


# --- FORCE_TASKS_ROUTER_START ---
# Ensure the tasks router is mounted even if routing.py misses it or startup path differs.
try:
    from api.routers.tasks import router as tasks_router  # type: ignore
except Exception:
    tasks_router = None

def _has_tasks_router(_app) -> bool:
    try:
        for r in getattr(_app, "routes", []):
            if getattr(r, "path", "") == "/api/tasks/transcribe":
                return True
    except Exception:
        pass
    return False

if tasks_router and not _has_tasks_router(app):
    app.include_router(tasks_router)
# --- FORCE_TASKS_ROUTER_END ---


# --- FORCE_TASKS_ENDPOINT_START ---
# A direct /api/tasks/transcribe endpoint to guarantee presence on every boot.
import os, logging
from fastapi import Header, HTTPException, Request
from pydantic import BaseModel

class _TasksTranscribeIn(BaseModel):
    filename: str

@app.post("/api/tasks/transcribe", include_in_schema=True, tags=["tasks"])
async def __force_tasks_transcribe(req: Request, payload: _TasksTranscribeIn, x_tasks_auth: str | None = Header(None)):
    if x_tasks_auth != os.getenv("TASKS_AUTH"):
        raise HTTPException(status_code=401, detail="unauthorized")
    logging.info(
        "event=tasks.transcribe.start filename=%s request_id=%s",
        payload.filename, req.headers.get("x-request-id")
    )
    try:
        from api.services.transcription import transcribe_media_file
        transcribe_media_file(payload.filename)
        logging.info(
            "event=tasks.transcribe.done filename=%s request_id=%s",
            payload.filename, req.headers.get("x-request-id")
        )
        return {"queued": False, "started": True}
    except Exception as e:
        logging.exception("event=tasks.transcribe.error filename=%s err=%s", payload.filename, e)
        # Bubble a clear error but don't crash the process
        raise HTTPException(status_code=500, detail="transcription-start-failed")
# --- FORCE_TASKS_ENDPOINT_END ---
